{"version":3,"file":"shell-toolkit.js","sources":["../src/lib/error-msg.mjs","../src/try-exec.mjs","../src/try-exec-async.mjs"],"sourcesContent":["const errorMsg = ({ cmd, msg = '', msgFunc, result, stderr }) => {\n  if (msg.length > 0) msg += ' '\n  if (msgFunc !== undefined) msg += msgFunc(result) + ' '\n  msg += `Failed to execute '${cmd}' (${result.code}); stderr: ${result.stderr}; stdout: ${result.stdout}`\n\n  return msg\n}\n\nexport { errorMsg }\n","import shell from 'shelljs'\n\nimport { errorMsg } from './lib/error-msg'\n\nconst tryExec = (cmd, { noThrow = false, ...opts } = {}) => {\n  const result = shell.exec(cmd, { silent : true, ...opts })\n  if (result.code !== 0 && noThrow !== true) {\n    throw new Error(errorMsg({ cmd, result, ...opts }))\n  }\n\n  return result\n}\n\nexport { tryExec }\n","import shell from 'shelljs'\n\nimport { errorMsg } from './lib/error-msg'\n\n/**\n * Asynchronously executes a shell command and returns a promise that resolves\n * with the result: `{code, stdout, stderr}`.\n *\n * The `opts` object will be passed to shelljs's `exec()` and then to Node's native\n * `child_process.exec()`. The most commonly used opts properties are:\n *\n * - cwd (string) - A full path to the working directory to execute the `cmd` in\n * - silent (boolean) - If `true` (default), the process won't log to `stdout`\n *\n * See shell.js docs: https://github.com/shelljs/shelljs#execcommand--options--callback\n * See Node docs: https://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback\n *\n * @example\n *\n *     const execAsync = require('execAsync');\n *     execAsync('ls -al', { silent: true, cwd: '/Users/admin/' });\n *\n * @param cmd  (string) - The shell command to execute\n * @param opts (object) - 'msg' and 'msgFunc' (which gets the results) may be used to specify or generate messages on failure. Any other opts are passed to shelljs.exec and then the notiv exec (see doc references)\n * @returns {String.<Promise>} - Resolves with the command results from `stdout`\n */\nconst tryExecAsync = (cmd, { noThrow, ...opts } = {}) => {\n  return new Promise(function(resolve, reject) {\n    // Execute the command, reject if we exit non-zero (i.e. error)\n    shell.exec(cmd, { silent : true, ...opts }, function(code, stdout, stderr) {\n      const result = new String(stdout) // eslint-disable-line no-new-wrappers\n      result.code = code\n      result.stderr = stderr\n      result.stdout = stdout\n\n      if (code !== 0 && noThrow !== true) {\n        return reject(new Error(errorMsg({ cmd, result, ...opts })))\n      }\n      // else; we mimic the behaviro of the underling shelljs.exec\n\n      return resolve(result)\n    })\n  })\n}\n\nexport { tryExecAsync }\n"],"names":["errorMsg","cmd","msg","msgFunc","result","stderr","length","undefined","code","stdout","tryExec","noThrow","opts","shell","exec","silent","Error","tryExecAsync","Promise","resolve","reject","String"],"mappings":";;2BAAMA,EAAWA,EAAGC,MAAKC,MAAM,GAAIC,UAASC,SAAQC,aAC9CH,EAAII,OAAS,IAAGJ,GAAO,UACXK,IAAZJ,IAAuBD,GAAOC,EAAQC,GAAU,KACpDF,GAAQ,sBAAqBD,OAASG,EAAOI,kBAAkBJ,EAAOC,mBAAmBD,EAAOK;gBCClFC,CAACT,GAAOU,WAAU,KAAUC,GAAS,MACnD,MAAMR,EAASS,EAAMC,KAAKb,EAAK,CAAEc,QAAS,KAASH;AACnD,GAAoB,IAAhBR,EAAOI,OAA0B,IAAZG,EACvB,MAAM,IAAIK,MAAMhB,EAAS,CAAEC,MAAKG,YAAWQ;AAG7C,OAAOR,CAAM,uBCgBMa,CAAChB,GAAOU,aAAYC,GAAS,KACzC,IAAIM,SAAQ,SAASC,EAASC,GAEnCP,EAAMC,KAAKb,EAAK,CAAEc,QAAS,KAASH,IAAQ,SAASJ,EAAMC,EAAQJ,GACjE,MAAMD,EAAS,IAAIiB,OAAOZ;AAK1B,OAJAL,EAAOI,KAAOA,EACdJ,EAAOC,OAASA,EAChBD,EAAOK,OAASA,EAEH,IAATD,IAA0B,IAAZG,EACTS,EAAO,IAAIJ,MAAMhB,EAAS,CAAEC,MAAKG,YAAWQ,MAI9CO,EAAQf,EACjB,GACF"}